{"ast":null,"code":"var _class, _temp;\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nvar _require = require('@uppy/core'),\n  Plugin = _require.Plugin;\nvar tus = require('tus-js-client');\nvar _require2 = require('@uppy/companion-client'),\n  Provider = _require2.Provider,\n  RequestClient = _require2.RequestClient,\n  Socket = _require2.Socket;\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\nvar settle = require('@uppy/utils/lib/settle');\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError');\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\nvar hasProperty = require('@uppy/utils/lib/hasProperty');\nvar getFingerprint = require('./getFingerprint');\n/** @typedef {import('..').TusOptions} TusOptions */\n\n/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */\n\n/** @typedef {import('@uppy/core').Uppy} Uppy */\n\n/** @typedef {import('@uppy/core').UppyFile} UppyFile */\n\n/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */\n\n/**\n * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13\n * excepted we removed 'fingerprint' key to avoid adding more dependencies\n *\n * @type {RawTusOptions}\n */\n\nvar tusDefaultOptions = {\n  endpoint: '',\n  uploadUrl: null,\n  metadata: {},\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false\n};\n/**\n * Tus resumable file uploader\n */\n\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(Tus, _Plugin);\n\n  /**\n   * @param {Uppy} uppy\n   * @param {TusOptions} opts\n   */\n  function Tus(uppy, opts) {\n    var _this;\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'Tus';\n    _this.title = 'Tus'; // set default options\n\n    var defaultOptions = {\n      autoRetry: true,\n      resume: true,\n      useFastRemoteRetry: true,\n      limit: 0,\n      retryDelays: [0, 1000, 3000, 5000],\n      withCredentials: false\n    }; // merge default options with the ones set by user\n\n    /** @type {import(\"..\").TusOptions} */\n\n    _this.opts = _extends({}, defaultOptions, opts);\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n\n    _this.requests = new RateLimitedQueue(_this.opts.limit);\n    _this.uploaders = Object.create(null);\n    _this.uploaderEvents = Object.create(null);\n    _this.uploaderSockets = Object.create(null);\n    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));\n    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  var _proto = Tus.prototype;\n  _proto.handleResetProgress = function handleResetProgress() {\n    var files = _extends({}, this.uppy.getState().files);\n    Object.keys(files).forEach(function (fileID) {\n      // Only clone the file object if it has a Tus `uploadUrl` attached.\n      if (files[fileID].tus && files[fileID].tus.uploadUrl) {\n        var tusState = _extends({}, files[fileID].tus);\n        delete tusState.uploadUrl;\n        files[fileID] = _extends({}, files[fileID], {\n          tus: tusState\n        });\n      }\n    });\n    this.uppy.setState({\n      files: files\n    });\n  }\n  /**\n   * Clean up all references for a file's upload: the tus.Upload instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * @param {string} fileID\n   */;\n\n  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    if (this.uploaders[fileID]) {\n      var uploader = this.uploaders[fileID];\n      uploader.abort();\n      if (opts.abort) {\n        // to avoid 423 error from tus server, we wait\n        // to be sure the previous request has been aborted before terminating the upload\n        // @todo remove the timeout when this \"wait\" is handled in tus-js-client internally\n        setTimeout(function () {\n          return uploader.abort(true);\n        }, 1000);\n      }\n      this.uploaders[fileID] = null;\n    }\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close();\n      this.uploaderSockets[fileID] = null;\n    }\n  }\n  /**\n   * Create a new Tus upload.\n   *\n   * A lot can happen during an upload, so this is quite hard to follow!\n   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.\n   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.\n   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners\n   *   for pausing, cancellation, removal, etc.\n   * - While the upload is in progress, it may be paused or cancelled.\n   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is\n   *   maintained.\n   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance\n   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).\n   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from\n   *   bypassing the limit.\n   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done\n   *   in the `this.requests` queue.\n   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.\n   *\n   * When working on this function, keep in mind:\n   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().\n   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.\n   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.\n   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.\n   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.\n   *\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */;\n\n  _proto.upload = function upload(file, current, total) {\n    var _this2 = this;\n    this.resetUploaderReferences(file.id); // Create a new tus upload\n\n    return new Promise(function (resolve, reject) {\n      _this2.uppy.emit('upload-started', file);\n      var opts = _extends({}, _this2.opts, file.tus || {});\n      /** @type {RawTusOptions} */\n\n      var uploadOptions = _extends({}, tusDefaultOptions, opts);\n      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2\n\n      if (opts.resume) {\n        uploadOptions.storeFingerprintForResuming = true;\n      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`\n      // now also includes `relativePath` for files added from folders.\n      // This means you can add 2 identical files, if one is in folder a,\n      // the other in folder b.\n\n      uploadOptions.fingerprint = getFingerprint(file);\n      uploadOptions.onBeforeRequest = function (req) {\n        var xhr = req.getUnderlyingObject();\n        xhr.withCredentials = !!opts.withCredentials;\n        if (typeof opts.onBeforeRequest === 'function') {\n          opts.onBeforeRequest(req);\n        }\n      };\n      uploadOptions.onError = function (err) {\n        _this2.uppy.log(err);\n        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;\n        if (isNetworkError(xhr)) {\n          err = new NetworkError(err, xhr);\n        }\n        _this2.resetUploaderReferences(file.id);\n        queuedRequest.done();\n        _this2.uppy.emit('upload-error', file, err);\n        reject(err);\n      };\n      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {\n        _this2.onReceiveUploadUrl(file, upload.url);\n        _this2.uppy.emit('upload-progress', file, {\n          uploader: _this2,\n          bytesUploaded: bytesUploaded,\n          bytesTotal: bytesTotal\n        });\n      };\n      uploadOptions.onSuccess = function () {\n        var uploadResp = {\n          uploadURL: upload.url\n        };\n        _this2.resetUploaderReferences(file.id);\n        queuedRequest.done();\n        _this2.uppy.emit('upload-success', file, uploadResp);\n        if (upload.url) {\n          _this2.uppy.log(\"Download \" + upload.file.name + \" from \" + upload.url);\n        }\n        resolve(upload);\n      };\n      var copyProp = function copyProp(obj, srcProp, destProp) {\n        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {\n          obj[destProp] = obj[srcProp];\n        }\n      };\n      /** @type {Record<string, string>} */\n\n      var meta = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (item) {\n        meta[item] = file.meta[item];\n      }); // tusd uses metadata fields 'filetype' and 'filename'\n\n      copyProp(meta, 'type', 'filetype');\n      copyProp(meta, 'name', 'filename');\n      uploadOptions.metadata = meta;\n      var upload = new tus.Upload(file.data, uploadOptions);\n      _this2.uploaders[file.id] = upload;\n      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2.\n\n      if (opts.resume) {\n        upload.findPreviousUploads().then(function (previousUploads) {\n          var previousUpload = previousUploads[0];\n          if (previousUpload) {\n            _this2.uppy.log(\"[Tus] Resuming upload of \" + file.id + \" started at \" + previousUpload.creationTime);\n            upload.resumeFromPreviousUpload(previousUpload);\n          }\n        });\n      }\n      var queuedRequest = _this2.requests.run(function () {\n        if (!file.isPaused) {\n          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.\n          // TODO: Remove in @uppy/tus v2.\n          Promise.resolve().then(function () {\n            upload.start();\n          });\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n        return function () {};\n      });\n      _this2.onFileRemove(file.id, function (targetFileID) {\n        queuedRequest.abort();\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n        resolve(\"upload \" + targetFileID + \" was removed\");\n      });\n      _this2.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          upload.abort();\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this2.requests.run(function () {\n            upload.start();\n            return function () {};\n          });\n        }\n      });\n      _this2.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        upload.abort();\n      });\n      _this2.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n      _this2.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n        if (file.error) {\n          upload.abort();\n        }\n        queuedRequest = _this2.requests.run(function () {\n          upload.start();\n          return function () {};\n        });\n      });\n    }).catch(function (err) {\n      _this2.uppy.emit('upload-error', file, err);\n      throw err;\n    });\n  }\n  /**\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */;\n\n  _proto.uploadRemote = function uploadRemote(file, current, total) {\n    var _this3 = this;\n    this.resetUploaderReferences(file.id);\n    var opts = _extends({}, this.opts);\n    if (file.tus) {\n      // Install file-specific upload overrides.\n      _extends(opts, file.tus);\n    }\n    this.uppy.emit('upload-started', file);\n    this.uppy.log(file.remote.url);\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n    return new Promise(function (resolve, reject) {\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet\n\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        uploadUrl: opts.uploadUrl,\n        protocol: 'tus',\n        size: file.data.size,\n        headers: opts.headers,\n        metadata: file.meta\n      })).then(function (res) {\n        _this3.uppy.setFileState(file.id, {\n          serverToken: res.token\n        });\n        file = _this3.uppy.getFile(file.id);\n        return _this3.connectToServerSocket(file);\n      }).then(function () {\n        resolve();\n      }).catch(function (err) {\n        _this3.uppy.emit('upload-error', file, err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * See the comment on the upload() method.\n   *\n   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().\n   *\n   * @param {UppyFile} file\n   */;\n\n  _proto.connectToServerSocket = function connectToServerSocket(file) {\n    var _this4 = this;\n    return new Promise(function (resolve, reject) {\n      var token = file.serverToken;\n      var host = getSocketHost(file.remote.companionUrl);\n      var socket = new Socket({\n        target: host + \"/api/\" + token,\n        autoOpen: false\n      });\n      _this4.uploaderSockets[file.id] = socket;\n      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n      _this4.onFileRemove(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n        _this4.resetUploaderReferences(file.id);\n        resolve(\"upload \" + file.id + \" was removed\");\n      });\n      _this4.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          socket.send('pause', {});\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this4.requests.run(function () {\n            socket.send('resume', {});\n            return function () {};\n          });\n        }\n      });\n      _this4.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n      });\n      _this4.onCancelAll(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n        _this4.resetUploaderReferences(file.id);\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n      _this4.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n        if (file.error) {\n          socket.send('pause', {});\n        }\n        queuedRequest = _this4.requests.run(function () {\n          socket.send('resume', {});\n          return function () {};\n        });\n      });\n      _this4.onRetry(file.id, function () {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n      _this4.onRetryAll(file.id, function () {\n        // See the comment in the onRetry() call\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n      socket.on('progress', function (progressData) {\n        return emitSocketProgress(_this4, progressData, file);\n      });\n      socket.on('error', function (errData) {\n        var message = errData.error.message;\n        var error = _extends(new Error(message), {\n          cause: errData.error\n        }); // If the remote retry optimisation should not be used,\n        // close the socket—this will tell companion to clear state and delete the file.\n\n        if (!_this4.opts.useFastRemoteRetry) {\n          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.\n\n          _this4.uppy.setFileState(file.id, {\n            serverToken: null\n          });\n        } else {\n          socket.close();\n        }\n        _this4.uppy.emit('upload-error', file, error);\n        queuedRequest.done();\n        reject(error);\n      });\n      socket.on('success', function (data) {\n        var uploadResp = {\n          uploadURL: data.url\n        };\n        _this4.uppy.emit('upload-success', file, uploadResp);\n        _this4.resetUploaderReferences(file.id);\n        queuedRequest.done();\n        resolve();\n      });\n      var queuedRequest = _this4.requests.run(function () {\n        socket.open();\n        if (file.isPaused) {\n          socket.send('pause', {});\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n        return function () {};\n      });\n    });\n  }\n  /**\n   * Store the uploadUrl on the file options, so that when Golden Retriever\n   * restores state, we will continue uploading to the correct URL.\n   *\n   * @param {UppyFile} file\n   * @param {string} uploadURL\n   */;\n\n  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {\n    var currentFile = this.uppy.getFile(file.id);\n    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.\n\n    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {\n      this.uppy.log('[Tus] Storing upload url');\n      this.uppy.setFileState(currentFile.id, {\n        tus: _extends({}, currentFile.tus, {\n          uploadUrl: uploadURL\n        })\n      });\n    }\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(string): void} cb\n   */;\n\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(boolean): void} cb\n   */;\n\n  _proto.onPause = function onPause(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */;\n\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */;\n\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this5 = this;\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this5.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */;\n\n  _proto.onPauseAll = function onPauseAll(fileID, cb) {\n    var _this6 = this;\n    this.uploaderEvents[fileID].on('pause-all', function () {\n      if (!_this6.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */;\n\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this7 = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */;\n\n  _proto.onResumeAll = function onResumeAll(fileID, cb) {\n    var _this8 = this;\n    this.uploaderEvents[fileID].on('resume-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {(UppyFile | FailedUppyFile)[]} files\n   */;\n\n  _proto.uploadFiles = function uploadFiles(files) {\n    var _this9 = this;\n    var promises = files.map(function (file, i) {\n      var current = i + 1;\n      var total = files.length;\n      if ('error' in file && file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n      if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n        if (!file.progress.uploadStarted || !file.isRestored) {\n          _this9.uppy.emit('upload-started', file);\n        }\n        return _this9.uploadRemote(file, current, total);\n      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        _this9.uppy.emit('upload-started', file);\n      }\n      return _this9.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  /**\n   * @param {string[]} fileIDs\n   */;\n\n  _proto.handleUpload = function handleUpload(fileIDs) {\n    var _this10 = this;\n    if (fileIDs.length === 0) {\n      this.uppy.log('[Tus] No files to upload');\n      return Promise.resolve();\n    }\n    if (this.opts.limit === 0) {\n      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');\n    }\n    this.uppy.log('[Tus] Uploading...');\n    var filesToUpload = fileIDs.map(function (fileID) {\n      return _this10.uppy.getFile(fileID);\n    });\n    return this.uploadFiles(filesToUpload).then(function () {\n      return null;\n    });\n  };\n  _proto.install = function install() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: true\n      })\n    });\n    this.uppy.addUploader(this.handleUpload);\n    this.uppy.on('reset-progress', this.handleResetProgress);\n    if (this.opts.autoRetry) {\n      this.uppy.on('back-online', this.uppy.retryAll);\n    }\n  };\n  _proto.uninstall = function uninstall() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: false\n      })\n    });\n    this.uppy.removeUploader(this.handleUpload);\n    if (this.opts.autoRetry) {\n      this.uppy.off('back-online', this.uppy.retryAll);\n    }\n  };\n  return Tus;\n}(Plugin), _class.VERSION = \"1.9.2\", _temp);","map":{"version":3,"names":["_class","_temp","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_assertThisInitialized","self","ReferenceError","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_require","require","Plugin","tus","_require2","Provider","RequestClient","Socket","emitSocketProgress","getSocketHost","settle","EventTracker","NetworkError","isNetworkError","RateLimitedQueue","hasProperty","getFingerprint","tusDefaultOptions","endpoint","uploadUrl","metadata","uploadSize","onProgress","onChunkComplete","onSuccess","onError","overridePatchMethod","headers","addRequestId","chunkSize","Infinity","retryDelays","parallelUploads","storeFingerprintForResuming","removeFingerprintOnSuccess","uploadLengthDeferred","uploadDataDuringCreation","module","exports","_Plugin","Tus","uppy","opts","_this","type","id","title","defaultOptions","autoRetry","resume","useFastRemoteRetry","limit","withCredentials","requests","uploaders","uploaderEvents","uploaderSockets","handleResetProgress","bind","handleUpload","_proto","files","getState","keys","forEach","fileID","tusState","setState","resetUploaderReferences","uploader","abort","setTimeout","remove","close","upload","file","current","total","_this2","Promise","resolve","reject","emit","uploadOptions","fingerprint","onBeforeRequest","req","xhr","getUnderlyingObject","err","log","originalRequest","queuedRequest","done","bytesUploaded","bytesTotal","onReceiveUploadUrl","url","uploadResp","uploadURL","name","copyProp","obj","srcProp","destProp","meta","metaFields","Array","isArray","item","Upload","data","findPreviousUploads","then","previousUploads","previousUpload","creationTime","resumeFromPreviousUpload","run","isPaused","start","onFileRemove","targetFileID","onPause","onPauseAll","onCancelAll","onResumeAll","error","catch","uploadRemote","_this3","remote","serverToken","connectToServerSocket","Client","providerOptions","provider","client","post","body","protocol","size","res","setFileState","token","getFile","_this4","host","companionUrl","socket","autoOpen","send","onRetry","isOpen","onRetryAll","on","progressData","errData","message","Error","cause","open","currentFile","cb","_this5","filesToRetry","_this6","_this7","_this8","uploadFiles","_this9","promises","map","isRemote","progress","uploadStarted","isRestored","fileIDs","_this10","filesToUpload","install","capabilities","resumableUploads","addUploader","retryAll","uninstall","removeUploader","off","VERSION"],"sources":["E:/integrate cloud/uppy/node_modules/@uppy/tus/lib/index.js"],"sourcesContent":["var _class, _temp;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _require = require('@uppy/core'),\n    Plugin = _require.Plugin;\n\nvar tus = require('tus-js-client');\n\nvar _require2 = require('@uppy/companion-client'),\n    Provider = _require2.Provider,\n    RequestClient = _require2.RequestClient,\n    Socket = _require2.Socket;\n\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\n\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\n\nvar settle = require('@uppy/utils/lib/settle');\n\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\n\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\n\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError');\n\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\n\nvar hasProperty = require('@uppy/utils/lib/hasProperty');\n\nvar getFingerprint = require('./getFingerprint');\n/** @typedef {import('..').TusOptions} TusOptions */\n\n/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */\n\n/** @typedef {import('@uppy/core').Uppy} Uppy */\n\n/** @typedef {import('@uppy/core').UppyFile} UppyFile */\n\n/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */\n\n/**\n * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13\n * excepted we removed 'fingerprint' key to avoid adding more dependencies\n *\n * @type {RawTusOptions}\n */\n\n\nvar tusDefaultOptions = {\n  endpoint: '',\n  uploadUrl: null,\n  metadata: {},\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false\n};\n/**\n * Tus resumable file uploader\n */\n\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(Tus, _Plugin);\n\n  /**\n   * @param {Uppy} uppy\n   * @param {TusOptions} opts\n   */\n  function Tus(uppy, opts) {\n    var _this;\n\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'Tus';\n    _this.title = 'Tus'; // set default options\n\n    var defaultOptions = {\n      autoRetry: true,\n      resume: true,\n      useFastRemoteRetry: true,\n      limit: 0,\n      retryDelays: [0, 1000, 3000, 5000],\n      withCredentials: false\n    }; // merge default options with the ones set by user\n\n    /** @type {import(\"..\").TusOptions} */\n\n    _this.opts = _extends({}, defaultOptions, opts);\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n\n    _this.requests = new RateLimitedQueue(_this.opts.limit);\n    _this.uploaders = Object.create(null);\n    _this.uploaderEvents = Object.create(null);\n    _this.uploaderSockets = Object.create(null);\n    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));\n    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Tus.prototype;\n\n  _proto.handleResetProgress = function handleResetProgress() {\n    var files = _extends({}, this.uppy.getState().files);\n\n    Object.keys(files).forEach(function (fileID) {\n      // Only clone the file object if it has a Tus `uploadUrl` attached.\n      if (files[fileID].tus && files[fileID].tus.uploadUrl) {\n        var tusState = _extends({}, files[fileID].tus);\n\n        delete tusState.uploadUrl;\n        files[fileID] = _extends({}, files[fileID], {\n          tus: tusState\n        });\n      }\n    });\n    this.uppy.setState({\n      files: files\n    });\n  }\n  /**\n   * Clean up all references for a file's upload: the tus.Upload instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * @param {string} fileID\n   */\n  ;\n\n  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (this.uploaders[fileID]) {\n      var uploader = this.uploaders[fileID];\n      uploader.abort();\n\n      if (opts.abort) {\n        // to avoid 423 error from tus server, we wait\n        // to be sure the previous request has been aborted before terminating the upload\n        // @todo remove the timeout when this \"wait\" is handled in tus-js-client internally\n        setTimeout(function () {\n          return uploader.abort(true);\n        }, 1000);\n      }\n\n      this.uploaders[fileID] = null;\n    }\n\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close();\n      this.uploaderSockets[fileID] = null;\n    }\n  }\n  /**\n   * Create a new Tus upload.\n   *\n   * A lot can happen during an upload, so this is quite hard to follow!\n   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.\n   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.\n   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners\n   *   for pausing, cancellation, removal, etc.\n   * - While the upload is in progress, it may be paused or cancelled.\n   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is\n   *   maintained.\n   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance\n   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).\n   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from\n   *   bypassing the limit.\n   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done\n   *   in the `this.requests` queue.\n   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.\n   *\n   * When working on this function, keep in mind:\n   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().\n   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.\n   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.\n   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.\n   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.\n   *\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.upload = function upload(file, current, total) {\n    var _this2 = this;\n\n    this.resetUploaderReferences(file.id); // Create a new tus upload\n\n    return new Promise(function (resolve, reject) {\n      _this2.uppy.emit('upload-started', file);\n\n      var opts = _extends({}, _this2.opts, file.tus || {});\n      /** @type {RawTusOptions} */\n\n\n      var uploadOptions = _extends({}, tusDefaultOptions, opts);\n\n      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2\n\n      if (opts.resume) {\n        uploadOptions.storeFingerprintForResuming = true;\n      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`\n      // now also includes `relativePath` for files added from folders.\n      // This means you can add 2 identical files, if one is in folder a,\n      // the other in folder b.\n\n\n      uploadOptions.fingerprint = getFingerprint(file);\n\n      uploadOptions.onBeforeRequest = function (req) {\n        var xhr = req.getUnderlyingObject();\n        xhr.withCredentials = !!opts.withCredentials;\n\n        if (typeof opts.onBeforeRequest === 'function') {\n          opts.onBeforeRequest(req);\n        }\n      };\n\n      uploadOptions.onError = function (err) {\n        _this2.uppy.log(err);\n\n        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;\n\n        if (isNetworkError(xhr)) {\n          err = new NetworkError(err, xhr);\n        }\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      };\n\n      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {\n        _this2.onReceiveUploadUrl(file, upload.url);\n\n        _this2.uppy.emit('upload-progress', file, {\n          uploader: _this2,\n          bytesUploaded: bytesUploaded,\n          bytesTotal: bytesTotal\n        });\n      };\n\n      uploadOptions.onSuccess = function () {\n        var uploadResp = {\n          uploadURL: upload.url\n        };\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-success', file, uploadResp);\n\n        if (upload.url) {\n          _this2.uppy.log(\"Download \" + upload.file.name + \" from \" + upload.url);\n        }\n\n        resolve(upload);\n      };\n\n      var copyProp = function copyProp(obj, srcProp, destProp) {\n        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {\n          obj[destProp] = obj[srcProp];\n        }\n      };\n      /** @type {Record<string, string>} */\n\n\n      var meta = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (item) {\n        meta[item] = file.meta[item];\n      }); // tusd uses metadata fields 'filetype' and 'filename'\n\n      copyProp(meta, 'type', 'filetype');\n      copyProp(meta, 'name', 'filename');\n      uploadOptions.metadata = meta;\n      var upload = new tus.Upload(file.data, uploadOptions);\n      _this2.uploaders[file.id] = upload;\n      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2.\n\n      if (opts.resume) {\n        upload.findPreviousUploads().then(function (previousUploads) {\n          var previousUpload = previousUploads[0];\n\n          if (previousUpload) {\n            _this2.uppy.log(\"[Tus] Resuming upload of \" + file.id + \" started at \" + previousUpload.creationTime);\n\n            upload.resumeFromPreviousUpload(previousUpload);\n          }\n        });\n      }\n\n      var queuedRequest = _this2.requests.run(function () {\n        if (!file.isPaused) {\n          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.\n          // TODO: Remove in @uppy/tus v2.\n          Promise.resolve().then(function () {\n            upload.start();\n          });\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n\n      _this2.onFileRemove(file.id, function (targetFileID) {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + targetFileID + \" was removed\");\n      });\n\n      _this2.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          upload.abort();\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this2.requests.run(function () {\n            upload.start();\n            return function () {};\n          });\n        }\n      });\n\n      _this2.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        upload.abort();\n      });\n\n      _this2.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this2.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          upload.abort();\n        }\n\n        queuedRequest = _this2.requests.run(function () {\n          upload.start();\n          return function () {};\n        });\n      });\n    }).catch(function (err) {\n      _this2.uppy.emit('upload-error', file, err);\n\n      throw err;\n    });\n  }\n  /**\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.uploadRemote = function uploadRemote(file, current, total) {\n    var _this3 = this;\n\n    this.resetUploaderReferences(file.id);\n\n    var opts = _extends({}, this.opts);\n\n    if (file.tus) {\n      // Install file-specific upload overrides.\n      _extends(opts, file.tus);\n    }\n\n    this.uppy.emit('upload-started', file);\n    this.uppy.log(file.remote.url);\n\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet\n\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        uploadUrl: opts.uploadUrl,\n        protocol: 'tus',\n        size: file.data.size,\n        headers: opts.headers,\n        metadata: file.meta\n      })).then(function (res) {\n        _this3.uppy.setFileState(file.id, {\n          serverToken: res.token\n        });\n\n        file = _this3.uppy.getFile(file.id);\n        return _this3.connectToServerSocket(file);\n      }).then(function () {\n        resolve();\n      }).catch(function (err) {\n        _this3.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      });\n    });\n  }\n  /**\n   * See the comment on the upload() method.\n   *\n   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().\n   *\n   * @param {UppyFile} file\n   */\n  ;\n\n  _proto.connectToServerSocket = function connectToServerSocket(file) {\n    var _this4 = this;\n\n    return new Promise(function (resolve, reject) {\n      var token = file.serverToken;\n      var host = getSocketHost(file.remote.companionUrl);\n      var socket = new Socket({\n        target: host + \"/api/\" + token,\n        autoOpen: false\n      });\n      _this4.uploaderSockets[file.id] = socket;\n      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n\n      _this4.onFileRemove(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was removed\");\n      });\n\n      _this4.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          socket.send('pause', {});\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this4.requests.run(function () {\n            socket.send('resume', {});\n            return function () {};\n          });\n        }\n      });\n\n      _this4.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n      });\n\n      _this4.onCancelAll(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this4.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          socket.send('pause', {});\n        }\n\n        queuedRequest = _this4.requests.run(function () {\n          socket.send('resume', {});\n          return function () {};\n        });\n      });\n\n      _this4.onRetry(file.id, function () {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      _this4.onRetryAll(file.id, function () {\n        // See the comment in the onRetry() call\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      socket.on('progress', function (progressData) {\n        return emitSocketProgress(_this4, progressData, file);\n      });\n      socket.on('error', function (errData) {\n        var message = errData.error.message;\n\n        var error = _extends(new Error(message), {\n          cause: errData.error\n        }); // If the remote retry optimisation should not be used,\n        // close the socket—this will tell companion to clear state and delete the file.\n\n\n        if (!_this4.opts.useFastRemoteRetry) {\n          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.\n\n\n          _this4.uppy.setFileState(file.id, {\n            serverToken: null\n          });\n        } else {\n          socket.close();\n        }\n\n        _this4.uppy.emit('upload-error', file, error);\n\n        queuedRequest.done();\n        reject(error);\n      });\n      socket.on('success', function (data) {\n        var uploadResp = {\n          uploadURL: data.url\n        };\n\n        _this4.uppy.emit('upload-success', file, uploadResp);\n\n        _this4.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n        resolve();\n      });\n\n      var queuedRequest = _this4.requests.run(function () {\n        socket.open();\n\n        if (file.isPaused) {\n          socket.send('pause', {});\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n    });\n  }\n  /**\n   * Store the uploadUrl on the file options, so that when Golden Retriever\n   * restores state, we will continue uploading to the correct URL.\n   *\n   * @param {UppyFile} file\n   * @param {string} uploadURL\n   */\n  ;\n\n  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {\n    var currentFile = this.uppy.getFile(file.id);\n    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.\n\n    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {\n      this.uppy.log('[Tus] Storing upload url');\n      this.uppy.setFileState(currentFile.id, {\n        tus: _extends({}, currentFile.tus, {\n          uploadUrl: uploadURL\n        })\n      });\n    }\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(string): void} cb\n   */\n  ;\n\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(boolean): void} cb\n   */\n  ;\n\n  _proto.onPause = function onPause(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this5 = this;\n\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this5.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onPauseAll = function onPauseAll(fileID, cb) {\n    var _this6 = this;\n\n    this.uploaderEvents[fileID].on('pause-all', function () {\n      if (!_this6.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this7 = this;\n\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onResumeAll = function onResumeAll(fileID, cb) {\n    var _this8 = this;\n\n    this.uploaderEvents[fileID].on('resume-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {(UppyFile | FailedUppyFile)[]} files\n   */\n  ;\n\n  _proto.uploadFiles = function uploadFiles(files) {\n    var _this9 = this;\n\n    var promises = files.map(function (file, i) {\n      var current = i + 1;\n      var total = files.length;\n\n      if ('error' in file && file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n\n      if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n        if (!file.progress.uploadStarted || !file.isRestored) {\n          _this9.uppy.emit('upload-started', file);\n        }\n\n        return _this9.uploadRemote(file, current, total);\n      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        _this9.uppy.emit('upload-started', file);\n      }\n\n      return _this9.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  /**\n   * @param {string[]} fileIDs\n   */\n  ;\n\n  _proto.handleUpload = function handleUpload(fileIDs) {\n    var _this10 = this;\n\n    if (fileIDs.length === 0) {\n      this.uppy.log('[Tus] No files to upload');\n      return Promise.resolve();\n    }\n\n    if (this.opts.limit === 0) {\n      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');\n    }\n\n    this.uppy.log('[Tus] Uploading...');\n    var filesToUpload = fileIDs.map(function (fileID) {\n      return _this10.uppy.getFile(fileID);\n    });\n    return this.uploadFiles(filesToUpload).then(function () {\n      return null;\n    });\n  };\n\n  _proto.install = function install() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: true\n      })\n    });\n    this.uppy.addUploader(this.handleUpload);\n    this.uppy.on('reset-progress', this.handleResetProgress);\n\n    if (this.opts.autoRetry) {\n      this.uppy.on('back-online', this.uppy.retryAll);\n    }\n  };\n\n  _proto.uninstall = function uninstall() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: false\n      })\n    });\n    this.uppy.removeUploader(this.handleUpload);\n\n    if (this.opts.autoRetry) {\n      this.uppy.off('back-online', this.uppy.retryAll);\n    }\n  };\n\n  return Tus;\n}(Plugin), _class.VERSION = \"1.9.2\", _temp);"],"mappings":"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"},"metadata":{},"sourceType":"script"}