{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar has = require('./hasProperty');\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  function Translator(locales) {\n    var _this = this;\n    this.locale = {\n      strings: {},\n      pluralize: function pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n        return 1;\n      }\n    };\n    if (Array.isArray(locales)) {\n      locales.forEach(function (locale) {\n        return _this._apply(locale);\n      });\n    } else {\n      this._apply(locales);\n    }\n  }\n  var _proto = Translator.prototype;\n  _proto._apply = function _apply(locale) {\n    if (!locale || !locale.strings) {\n      return;\n    }\n    var prevLocale = this.locale;\n    this.locale = _extends({}, prevLocale, {\n      strings: _extends({}, prevLocale.strings, locale.strings)\n    });\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;\n  }\n  /**\n   * Takes a string with placeholder variables like `%{smart_count} file selected`\n   * and replaces it with values from options `{smart_count: 5}`\n   *\n   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n   *\n   * @param {string} phrase that needs interpolation, with placeholders\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {any[]} interpolated\n   */;\n\n  _proto.interpolate = function interpolate(phrase, options) {\n    var _String$prototype = String.prototype,\n      split = _String$prototype.split,\n      replace = _String$prototype.replace;\n    var dollarRegex = /\\$/g;\n    var dollarBillsYall = '$$$$';\n    var interpolated = [phrase];\n    for (var arg in options) {\n      if (arg !== '_' && has(options, arg)) {\n        // Ensure replacement value is escaped to prevent special $-prefixed\n        // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n        // be escaped with \"$\" itself, and we need two in the resulting output.\n        var replacement = options[arg];\n        if (typeof replacement === 'string') {\n          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);\n        } // We create a new `RegExp` each time instead of using a more-efficient\n        // string replace so that the same argument can be replaced multiple times\n        // in the same phrase.\n\n        interpolated = insertReplacement(interpolated, new RegExp(\"%\\\\{\" + arg + \"\\\\}\", 'g'), replacement);\n      }\n    }\n    return interpolated;\n    function insertReplacement(source, rx, replacement) {\n      var newParts = [];\n      source.forEach(function (chunk) {\n        // When the source contains multiple placeholders for interpolation,\n        // we should ignore chunks that are not strings, because those\n        // can be JSX objects and will be otherwise incorrectly turned into strings.\n        // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n        if (typeof chunk !== 'string') {\n          return newParts.push(chunk);\n        }\n        split.call(chunk, rx).forEach(function (raw, i, list) {\n          if (raw !== '') {\n            newParts.push(raw);\n          } // Interlace with the `replacement` value\n\n          if (i < list.length - 1) {\n            newParts.push(replacement);\n          }\n        });\n      });\n      return newParts;\n    }\n  }\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */;\n\n  _proto.translate = function translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */;\n\n  _proto.translateArray = function translateArray(key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(\"missing string: \" + key);\n    }\n    var string = this.locale.strings[key];\n    var hasPluralForms = typeof string === 'object';\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        var plural = this.locale.pluralize(options.smart_count);\n        return this.interpolate(string[plural], options);\n      }\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n    }\n    return this.interpolate(string, options);\n  };\n  return Translator;\n}();","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","has","require","module","exports","Translator","locales","_this","locale","strings","pluralize","n","Array","isArray","forEach","_apply","_proto","prevLocale","interpolate","phrase","options","_String$prototype","String","split","replace","dollarRegex","dollarBillsYall","interpolated","arg","replacement","insertReplacement","RegExp","rx","newParts","chunk","push","raw","list","translate","translateArray","join","Error","string","hasPluralForms","smart_count","plural"],"sources":["E:/integrate cloud/uppy/node_modules/@uppy/utils/lib/Translator.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar has = require('./hasProperty');\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  function Translator(locales) {\n    var _this = this;\n\n    this.locale = {\n      strings: {},\n      pluralize: function pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n\n        return 1;\n      }\n    };\n\n    if (Array.isArray(locales)) {\n      locales.forEach(function (locale) {\n        return _this._apply(locale);\n      });\n    } else {\n      this._apply(locales);\n    }\n  }\n\n  var _proto = Translator.prototype;\n\n  _proto._apply = function _apply(locale) {\n    if (!locale || !locale.strings) {\n      return;\n    }\n\n    var prevLocale = this.locale;\n    this.locale = _extends({}, prevLocale, {\n      strings: _extends({}, prevLocale.strings, locale.strings)\n    });\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;\n  }\n  /**\n   * Takes a string with placeholder variables like `%{smart_count} file selected`\n   * and replaces it with values from options `{smart_count: 5}`\n   *\n   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n   *\n   * @param {string} phrase that needs interpolation, with placeholders\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {any[]} interpolated\n   */\n  ;\n\n  _proto.interpolate = function interpolate(phrase, options) {\n    var _String$prototype = String.prototype,\n        split = _String$prototype.split,\n        replace = _String$prototype.replace;\n    var dollarRegex = /\\$/g;\n    var dollarBillsYall = '$$$$';\n    var interpolated = [phrase];\n\n    for (var arg in options) {\n      if (arg !== '_' && has(options, arg)) {\n        // Ensure replacement value is escaped to prevent special $-prefixed\n        // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n        // be escaped with \"$\" itself, and we need two in the resulting output.\n        var replacement = options[arg];\n\n        if (typeof replacement === 'string') {\n          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);\n        } // We create a new `RegExp` each time instead of using a more-efficient\n        // string replace so that the same argument can be replaced multiple times\n        // in the same phrase.\n\n\n        interpolated = insertReplacement(interpolated, new RegExp(\"%\\\\{\" + arg + \"\\\\}\", 'g'), replacement);\n      }\n    }\n\n    return interpolated;\n\n    function insertReplacement(source, rx, replacement) {\n      var newParts = [];\n      source.forEach(function (chunk) {\n        // When the source contains multiple placeholders for interpolation,\n        // we should ignore chunks that are not strings, because those\n        // can be JSX objects and will be otherwise incorrectly turned into strings.\n        // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n        if (typeof chunk !== 'string') {\n          return newParts.push(chunk);\n        }\n\n        split.call(chunk, rx).forEach(function (raw, i, list) {\n          if (raw !== '') {\n            newParts.push(raw);\n          } // Interlace with the `replacement` value\n\n\n          if (i < list.length - 1) {\n            newParts.push(replacement);\n          }\n        });\n      });\n      return newParts;\n    }\n  }\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */\n  ;\n\n  _proto.translate = function translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */\n  ;\n\n  _proto.translateArray = function translateArray(key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(\"missing string: \" + key);\n    }\n\n    var string = this.locale.strings[key];\n    var hasPluralForms = typeof string === 'object';\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        var plural = this.locale.pluralize(options.smart_count);\n        return this.interpolate(string[plural], options);\n      }\n\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n    }\n\n    return this.interpolate(string, options);\n  };\n\n  return Translator;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"script"}