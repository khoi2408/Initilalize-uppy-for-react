{"ast":null,"code":"var findIndex = require('./findIndex');\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n  var _proto = RateLimitedQueue.prototype;\n  _proto._call = function _call(fn) {\n    var _this = this;\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        _this._queueNext();\n      }\n    };\n  };\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this;\n\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n    var next = this.queuedHandlers.shift();\n    var handler = this._call(next.fn);\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n    if (options === void 0) {\n      options = {};\n    }\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n    return handler;\n  };\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n    return this._queue(fn, queueOptions);\n  };\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n      return outerPromise;\n    };\n  };\n  return RateLimitedQueue;\n}();","map":{"version":3,"names":["findIndex","require","createCancelError","Error","module","exports","RateLimitedQueue","limit","Infinity","activeRequests","queuedHandlers","_proto","prototype","_call","fn","_this","_done","cancelActive","err","abort","_queueNext","done","_this2","Promise","resolve","then","_next","length","next","shift","handler","_queue","options","_this3","priority","_dequeue","index","other","push","splice","indexOf","run","queueOptions","wrapPromiseFunction","_this4","_len","arguments","args","Array","_key","queuedRequest","outerPromise","reject","cancelError","innerPromise","apply","result"],"sources":["E:/integrate cloud/uppy/node_modules/@uppy/utils/lib/RateLimitedQueue.js"],"sourcesContent":["var findIndex = require('./findIndex');\n\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n\n  var _proto = RateLimitedQueue.prototype;\n\n  _proto._call = function _call(fn) {\n    var _this = this;\n\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n\n        _this._queueNext();\n      }\n    };\n  };\n\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this;\n\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n\n    var next = this.queuedHandlers.shift();\n\n    var handler = this._call(next.fn);\n\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n\n    return handler;\n  };\n\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n\n    return this._queue(fn, queueOptions);\n  };\n\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n\n      return outerPromise;\n    };\n  };\n\n  return RateLimitedQueue;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"script"}