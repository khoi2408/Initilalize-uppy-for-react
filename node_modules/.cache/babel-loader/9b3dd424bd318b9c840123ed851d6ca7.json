{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/* global window */\nimport { Base64 } from 'js-base64';\nimport URL from 'url-parse';\nimport DetailedError from './error';\nimport { log } from './logger';\nimport uuid from './uuid';\nvar defaultOptions = {\n  endpoint: null,\n  uploadUrl: null,\n  metadata: {},\n  fingerprint: null,\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  _onUploadUrlAvailable: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  onBeforeRequest: null,\n  onAfterResponse: null,\n  onShouldRetry: null,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false,\n  urlStorage: null,\n  fileReader: null,\n  httpStack: null\n};\nvar BaseUpload = /*#__PURE__*/function () {\n  function BaseUpload(file, options) {\n    _classCallCheck(this, BaseUpload);\n\n    // Warn about removed options from previous versions\n    if ('resume' in options) {\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console\n    } // The default options will already be added from the wrapper classes.\n\n    this.options = options; // Cast chunkSize to integer\n\n    this.options.chunkSize = +this.options.chunkSize; // The storage module used to store URLs\n\n    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying request object for the current PATCH request\n\n    this._req = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,\n\n    this._urlStorageKey = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Zero indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploadUrls = null;\n  }\n  /**\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\n   * request to the specified upload URL. This is only possible if the server supports the\n   * Termination extension. If the `options.retryDelays` property is set, the method will\n   * also retry if an error ocurrs.\n   *\n   * @param {String} url The upload's URL which will be terminated.\n   * @param {object} options Optional options for influencing HTTP requests.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n\n  _createClass(BaseUpload, [{\n    key: \"findPreviousUploads\",\n    value: function findPreviousUploads() {\n      var _this = this;\n      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {\n        return _this._urlStorage.findUploadsByFingerprint(fingerprint);\n      });\n    }\n  }, {\n    key: \"resumeFromPreviousUpload\",\n    value: function resumeFromPreviousUpload(previousUpload) {\n      this.url = previousUpload.uploadUrl || null;\n      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;\n      this._urlStorageKey = previousUpload.urlStorageKey;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n      var file = this.file;\n      if (!file) {\n        this._emitError(new Error('tus: no file or stream to upload provided'));\n        return;\n      }\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));\n        return;\n      }\n      var retryDelays = this.options.retryDelays;\n      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\n        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));\n        return;\n      }\n      if (this.options.parallelUploads > 1) {\n        // Test which options are incompatible with parallel uploads.\n        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {\n          if (_this2.options[optionName]) {\n            _this2._emitError(new Error(\"tus: cannot use the \".concat(optionName, \" option when parallelUploads is enabled\")));\n          }\n        });\n      }\n      this.options.fingerprint(file, this.options).then(function (fingerprint) {\n        if (fingerprint == null) {\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');\n        } else {\n          log(\"Calculated fingerprint: \".concat(fingerprint));\n        }\n        _this2._fingerprint = fingerprint;\n        if (_this2._source) {\n          return _this2._source;\n        }\n        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);\n      }).then(function (source) {\n        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from\n        // an upload which used multiple requests, we start a parallel upload.\n\n        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {\n          _this2._startParallelUpload();\n        } else {\n          _this2._startSingleUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this2._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a parallelized upload, where one file is split into\n     * multiple request which are run in parallel.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_startParallelUpload\",\n    value: function _startParallelUpload() {\n      var _this3 = this;\n      var totalSize = this._size = this._source.size;\n      var totalProgress = 0;\n      this._parallelUploads = [];\n      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate\n      // requests. Here we generate the start and end position for the slices.\n\n      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs\n\n      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective\n      // upload is completed.\n\n      var uploads = parts.map(function (part, index) {\n        var lastPartProgress = 0;\n        return _this3._source.slice(part.start, part.end).then(function (_ref) {\n          var value = _ref.value;\n          return new Promise(function (resolve, reject) {\n            // Merge with the user supplied options but overwrite some values.\n            var options = _objectSpread(_objectSpread({}, _this3.options), {}, {\n              // If available, the partial upload should be resumed from a previous URL.\n              uploadUrl: part.uploadUrl || null,\n              // We take manually care of resuming for partial uploads, so they should\n              // not be stored in the URL storage.\n              storeFingerprintForResuming: false,\n              removeFingerprintOnSuccess: false,\n              // Reset the parallelUploads option to not cause recursion.\n              parallelUploads: 1,\n              metadata: {},\n              // Add the header to indicate the this is a partial upload.\n              headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {\n                'Upload-Concat': 'partial'\n              }),\n              // Reject or resolve the promise if the upload errors or completes.\n              onSuccess: resolve,\n              onError: reject,\n              // Based in the progress for this partial upload, calculate the progress\n              // for the entire final upload.\n              onProgress: function onProgress(newPartProgress) {\n                totalProgress = totalProgress - lastPartProgress + newPartProgress;\n                lastPartProgress = newPartProgress;\n                _this3._emitProgress(totalProgress, totalSize);\n              },\n              // Wait until every partial upload has an upload URL, so we can add\n              // them to the URL storage.\n              _onUploadUrlAvailable: function _onUploadUrlAvailable() {\n                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL\n\n                if (_this3._parallelUploadUrls.filter(function (u) {\n                  return !!u;\n                }).length === parts.length) {\n                  _this3._saveUploadInUrlStorage();\n                }\n              }\n            });\n            var upload = new BaseUpload(value, options);\n            upload.start(); // Store the upload in an array, so we can later abort them if necessary.\n\n            _this3._parallelUploads.push(upload);\n          });\n        });\n      });\n      var req; // Wait until all partial uploads are finished and we can send the POST request for\n      // creating the final upload.\n\n      Promise.all(uploads).then(function () {\n        req = _this3._openRequest('POST', _this3.options.endpoint);\n        req.setHeader('Upload-Concat', \"final;\".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added\n\n        var metadata = encodeMetadata(_this3.options.metadata);\n        if (metadata !== '') {\n          req.setHeader('Upload-Metadata', metadata);\n        }\n        return _this3._sendRequest(req, null);\n      }).then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n          return;\n        }\n        var location = res.getHeader('Location');\n        if (location == null) {\n          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');\n          return;\n        }\n        _this3.url = resolveUrl(_this3.options.endpoint, location);\n        log(\"Created upload at \".concat(_this3.url));\n        _this3._emitSuccess();\n      })[\"catch\"](function (err) {\n        _this3._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\n     * uploaded in a sequential matter.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_startSingleUpload\",\n    value: function _startSingleUpload() {\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n        if (isNaN(this._size)) {\n          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));\n          return;\n        }\n      } else {\n        this._size = this._source.size;\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option\"));\n          return;\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _performUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        log(\"Resuming upload from previous URL: \".concat(this.url));\n        this._resumeUpload();\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n      if (this.options.uploadUrl != null) {\n        log(\"Resuming upload from provided URL: \".concat(this.options.uploadUrl));\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n      } // An upload has not started for the file yet, so we start a new one\n\n      log('Creating a new upload');\n      this._createUpload();\n    }\n    /**\n     * Abort any running request and stop the current upload. After abort is called, no event\n     * handler will be invoked anymore. You can use the `start` method to resume the upload\n     * again.\n     * If `shouldTerminate` is true, the `terminate` function will be called to remove the\n     * current upload from the server.\n     *\n     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\n     * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n     */\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate) {\n      var _this4 = this;\n\n      // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.\n\n      if (this._parallelUploads != null) {\n        this._parallelUploads.forEach(function (upload) {\n          upload.abort(shouldTerminate);\n        });\n      } // Stop any current running request.\n\n      if (this._req !== null) {\n        this._req.abort();\n        this._source.close();\n      }\n      this._aborted = true; // Stop any timeout used for initiating a retry.\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n      if (!shouldTerminate || this.url == null) {\n        return Promise.resolve();\n      }\n      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.\n      .then(function () {\n        return _this4._removeFromUrlStorage();\n      });\n    }\n  }, {\n    key: \"_emitHttpError\",\n    value: function _emitHttpError(req, res, message, causingErr) {\n      this._emitError(new DetailedError(message, causingErr, req, res));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      var _this5 = this;\n\n      // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\n      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.\n\n      if (this.options.retryDelays != null) {\n        // We will reset the attempt counter if\n        // - we were already able to connect to the server (offset != null) and\n        // - we were able to upload a small chunk of data to the server\n        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;\n        if (shouldResetDelays) {\n          this._retryAttempt = 0;\n        }\n        if (shouldRetry(err, this._retryAttempt, this.options)) {\n          var delay = this.options.retryDelays[this._retryAttempt++];\n          this._offsetBeforeRetry = this._offset;\n          this._retryTimeout = setTimeout(function () {\n            _this5.start();\n          }, delay);\n          return;\n        }\n      }\n      if (typeof this.options.onError === 'function') {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n    /**\n     * Publishes notification if the upload has been successfully completed.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (this.options.removeFingerprintOnSuccess) {\n        // Remove stored fingerprint and corresponding endpoint. This causes\n        // new uploads of the same file to be treated as a different file.\n        this._removeFromUrlStorage();\n      }\n      if (typeof this.options.onSuccess === 'function') {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     *\n     * @param {number} bytesSent  Number of bytes sent to the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === 'function') {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param {number} chunkSize  Size of the chunk that was accepted by the server.\n     * @param {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === 'function') {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this6 = this;\n      if (!this.options.endpoint) {\n        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));\n        return;\n      }\n      var req = this._openRequest('POST', this.options.endpoint);\n      if (this.options.uploadLengthDeferred) {\n        req.setHeader('Upload-Defer-Length', 1);\n      } else {\n        req.setHeader('Upload-Length', this._size);\n      } // Add metadata if values have been added\n\n      var metadata = encodeMetadata(this.options.metadata);\n      if (metadata !== '') {\n        req.setHeader('Upload-Metadata', metadata);\n      }\n      var promise;\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        promise = this._addChunkToRequest(req);\n      } else {\n        promise = this._sendRequest(req, null);\n      }\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n          return;\n        }\n        var location = res.getHeader('Location');\n        if (location == null) {\n          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');\n          return;\n        }\n        _this6.url = resolveUrl(_this6.options.endpoint, location);\n        log(\"Created upload at \".concat(_this6.url));\n        if (typeof _this6.options._onUploadUrlAvailable === 'function') {\n          _this6.options._onUploadUrlAvailable();\n        }\n        if (_this6._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this6._emitSuccess();\n          _this6._source.close();\n          return;\n        }\n        _this6._saveUploadInUrlStorage();\n        if (_this6.options.uploadDataDuringCreation) {\n          _this6._handleUploadResponse(req, res);\n        } else {\n          _this6._offset = 0;\n          _this6._performUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);\n      });\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this7 = this;\n      var req = this._openRequest('HEAD', this.url);\n      var promise = this._sendRequest(req, null);\n      promise.then(function (res) {\n        var status = res.getStatus();\n        if (!inStatusCategory(status, 200)) {\n          if (inStatusCategory(status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this7._removeFromUrlStorage();\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n          if (status === 423) {\n            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');\n            return;\n          }\n          if (!_this7.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');\n            return;\n          } // Try to create a new upload\n\n          _this7.url = null;\n          _this7._createUpload();\n          return;\n        }\n        var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n        if (isNaN(offset)) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');\n          return;\n        }\n        var length = parseInt(res.getHeader('Upload-Length'), 10);\n        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');\n          return;\n        }\n        if (typeof _this7.options._onUploadUrlAvailable === 'function') {\n          _this7.options._onUploadUrlAvailable();\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n        if (offset === length) {\n          _this7._emitProgress(length, length);\n          _this7._emitSuccess();\n          return;\n        }\n        _this7._offset = offset;\n        _this7._performUpload();\n      })[\"catch\"](function (err) {\n        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);\n      });\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_performUpload\",\n    value: function _performUpload() {\n      var _this8 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n      var req; // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        req = this._openRequest('POST', this.url);\n        req.setHeader('X-HTTP-Method-Override', 'PATCH');\n      } else {\n        req = this._openRequest('PATCH', this.url);\n      }\n      req.setHeader('Upload-Offset', this._offset);\n      var promise = this._addChunkToRequest(req);\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');\n          return;\n        }\n        _this8._handleUploadResponse(req, res);\n      })[\"catch\"](function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this8._aborted) {\n          return;\n        }\n        _this8._emitHttpError(req, null, \"tus: failed to upload chunk at offset \".concat(_this8._offset), err);\n      });\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied request object. It will not handle the response.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(req) {\n      var _this9 = this;\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n      req.setProgressHandler(function (bytesSent) {\n        _this9._emitProgress(start + bytesSent, _this9._size);\n      });\n      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n      return this._source.slice(start, end).then(function (_ref2) {\n        var value = _ref2.value,\n          done = _ref2.done;\n\n        // If the upload length is deferred, the upload size was not specified during\n        // upload creation. So, if the file reader is done reading, we know the total\n        // upload size and can tell the tus server.\n        if (_this9.options.uploadLengthDeferred && done) {\n          _this9._size = _this9._offset + (value && value.size ? value.size : 0);\n          req.setHeader('Upload-Length', _this9._size);\n        }\n        if (value === null) {\n          return _this9._sendRequest(req);\n        }\n        _this9._emitProgress(_this9._offset, _this9._size);\n        return _this9._sendRequest(req, value);\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(req, res) {\n      var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n      if (isNaN(offset)) {\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value');\n        return;\n      }\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n      this._offset = offset;\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n      this._performUpload();\n    }\n    /**\n     * Create a new HTTP request object with the given method and URL.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_openRequest\",\n    value: function _openRequest(method, url) {\n      var req = openRequest(method, url, this.options);\n      this._req = req;\n      return req;\n    }\n    /**\n     * Remove the entry in the URL storage, if it has been saved before.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_removeFromUrlStorage\",\n    value: function _removeFromUrlStorage() {\n      var _this10 = this;\n      if (!this._urlStorageKey) return;\n      this._urlStorage.removeUpload(this._urlStorageKey)[\"catch\"](function (err) {\n        _this10._emitError(err);\n      });\n      this._urlStorageKey = null;\n    }\n    /**\n     * Add the upload URL to the URL storage, if possible.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_saveUploadInUrlStorage\",\n    value: function _saveUploadInUrlStorage() {\n      var _this11 = this;\n\n      // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.\n      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {\n        return;\n      }\n      var storedUpload = {\n        size: this._size,\n        metadata: this.options.metadata,\n        creationTime: new Date().toString()\n      };\n      if (this._parallelUploads) {\n        // Save multiple URLs if the parallelUploads option is used ...\n        storedUpload.parallelUploadUrls = this._parallelUploadUrls;\n      } else {\n        // ... otherwise we just save the one available URL.\n        storedUpload.uploadUrl = this.url;\n      }\n      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {\n        return _this11._urlStorageKey = urlStorageKey;\n      })[\"catch\"](function (err) {\n        _this11._emitError(err);\n      });\n    }\n    /**\n     * Send a request with the provided body.\n     *\n     * @api private\n     */\n  }, {\n    key: \"_sendRequest\",\n    value: function _sendRequest(req) {\n      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return sendRequest(req, body, this.options);\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options) {\n      // Count the number of arguments to see if a callback is being provided as the last\n      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {\n        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Note that in order for the trick above to work, a default value cannot be set for `options`,\n      // so the check below replaces the old default `{}`.\n\n      if (options === undefined) {\n        options = {};\n      }\n      var req = openRequest('DELETE', url, options);\n      return sendRequest(req, null, options).then(function (res) {\n        // A 204 response indicates a successfull request\n        if (res.getStatus() === 204) {\n          return;\n        }\n        throw new DetailedError('tus: unexpected response while terminating upload', null, req, res);\n      })[\"catch\"](function (err) {\n        if (!(err instanceof DetailedError)) {\n          err = new DetailedError('tus: failed to terminate upload', err, req, null);\n        }\n        if (!shouldRetry(err, 0, options)) {\n          throw err;\n        } // Instead of keeping track of the retry attempts, we remove the first element from the delays\n        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\n        // We recursively call the terminate function will removing elements from the retryDelays array.\n\n        var delay = options.retryDelays[0];\n        var remainingDelays = options.retryDelays.slice(1);\n        var newOptions = _objectSpread(_objectSpread({}, options), {}, {\n          retryDelays: remainingDelays\n        });\n        return new Promise(function (resolve) {\n          return setTimeout(resolve, delay);\n        }).then(function () {\n          return BaseUpload.terminate(url, newOptions);\n        });\n      });\n    }\n  }]);\n  return BaseUpload;\n}();\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n  for (var key in metadata) {\n    encoded.push(\"\".concat(key, \" \").concat(Base64.encode(metadata[key])));\n  }\n  return encoded.join(',');\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n/**\n * Create a new HTTP request with the specified method and URL.\n * The necessary headers that are included in every request\n * will be added, including the request ID.\n *\n * @api private\n */\n\nfunction openRequest(method, url, options) {\n  var req = options.httpStack.createRequest(method, url);\n  req.setHeader('Tus-Resumable', '1.0.0');\n  var headers = options.headers || {};\n  for (var name in headers) {\n    req.setHeader(name, headers[name]);\n  }\n  if (options.addRequestId) {\n    var requestId = uuid();\n    req.setHeader('X-Request-ID', requestId);\n  }\n  return req;\n}\n/**\n * Send a request with the provided body while invoking the onBeforeRequest\n * and onAfterResponse callbacks.\n *\n * @api private\n */\n\nfunction sendRequest(req, body, options) {\n  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();\n  return onBeforeRequestPromise.then(function () {\n    return req.send(body).then(function (res) {\n      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();\n      return onAfterResponsePromise.then(function () {\n        return res;\n      });\n    });\n  });\n}\n/**\n * Checks whether the browser running this code has internet access.\n * This function will always return true in the node.js environment\n *\n * @api private\n */\n\nfunction isOnline() {\n  var online = true;\n  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {\n    online = false;\n  }\n  return online;\n}\n/**\n * Checks whether or not it is ok to retry a request.\n * @param {Error} err the error returned from the last request\n * @param {number} retryAttempt the number of times the request has already been retried\n * @param {object} options tus Upload options\n *\n * @api private\n */\n\nfunction shouldRetry(err, retryAttempt, options) {\n  // We only attempt a retry if\n  // - retryDelays option is set\n  // - we didn't exceed the maxium number of retries, yet, and\n  // - this error was caused by a request or it's response and\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\n  // a onShouldRetry is specified and returns true\n  // - the browser does not indicate that we are offline\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\n    return false;\n  }\n  if (options && typeof options.onShouldRetry === 'function') {\n    return options.onShouldRetry(err, retryAttempt, options);\n  }\n  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();\n}\n/**\n * Resolve a relative link given the origin as source. For example,\n * if a HTTP request to http://example.com/files/ returns a Location\n * header with the value /upload/abc, the resolved URL will be:\n * http://example.com/upload/abc\n */\n\nfunction resolveUrl(origin, link) {\n  return new URL(link, origin).toString();\n}\n/**\n * Calculate the start and end positions for the parts if an upload\n * is split into multiple parallel requests.\n *\n * @param {number} totalSize The byte size of the upload, which will be split.\n * @param {number} partCount The number in how many parts the upload will be split.\n * @param {string[]} previousUrls The upload URLs for previous parts.\n * @return {object[]}\n * @api private\n */\n\nfunction splitSizeIntoParts(totalSize, partCount, previousUrls) {\n  var partSize = Math.floor(totalSize / partCount);\n  var parts = [];\n  for (var i = 0; i < partCount; i++) {\n    parts.push({\n      start: partSize * i,\n      end: partSize * (i + 1)\n    });\n  }\n  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.\n\n  if (previousUrls) {\n    parts.forEach(function (part, index) {\n      part.uploadUrl = previousUrls[index] || null;\n    });\n  }\n  return parts;\n}\nBaseUpload.defaultOptions = defaultOptions;\nexport default BaseUpload;","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","Base64","URL","DetailedError","log","uuid","defaultOptions","endpoint","uploadUrl","metadata","fingerprint","uploadSize","onProgress","onChunkComplete","onSuccess","onError","_onUploadUrlAvailable","overridePatchMethod","headers","addRequestId","onBeforeRequest","onAfterResponse","onShouldRetry","chunkSize","Infinity","retryDelays","parallelUploads","storeFingerprintForResuming","removeFingerprintOnSuccess","uploadLengthDeferred","uploadDataDuringCreation","urlStorage","fileReader","httpStack","BaseUpload","file","options","console","_urlStorage","url","_req","_fingerprint","_urlStorageKey","_offset","_aborted","_size","_source","_retryAttempt","_retryTimeout","_offsetBeforeRetry","_parallelUploads","_parallelUploadUrls","findPreviousUploads","_this","then","findUploadsByFingerprint","resumeFromPreviousUpload","previousUpload","parallelUploadUrls","urlStorageKey","start","_this2","_emitError","Error","toString","call","optionName","concat","openFile","_startParallelUpload","_startSingleUpload","err","_this3","totalSize","size","totalProgress","partCount","parts","splitSizeIntoParts","Array","uploads","map","part","index","lastPartProgress","slice","end","_ref","Promise","resolve","reject","newPartProgress","_emitProgress","upload","u","_saveUploadInUrlStorage","req","all","_openRequest","setHeader","join","encodeMetadata","_sendRequest","res","inStatusCategory","getStatus","_emitHttpError","location","getHeader","resolveUrl","_emitSuccess","isNaN","_resumeUpload","_createUpload","abort","shouldTerminate","_this4","close","clearTimeout","terminate","_removeFromUrlStorage","message","causingErr","_this5","shouldResetDelays","shouldRetry","delay","setTimeout","bytesSent","bytesTotal","_emitChunkComplete","bytesAccepted","_this6","promise","_addChunkToRequest","_handleUploadResponse","_performUpload","_this7","status","offset","parseInt","_this8","_this9","setProgressHandler","_ref2","done","method","openRequest","_this10","removeUpload","_this11","storedUpload","creationTime","Date","addUpload","body","undefined","sendRequest","remainingDelays","newOptions","encoded","encode","category","createRequest","name","requestId","onBeforeRequestPromise","send","onAfterResponsePromise","isOnline","online","window","navigator","onLine","retryAttempt","originalRequest","originalResponse","origin","link","previousUrls","partSize","Math","floor"],"sources":["E:/integrate cloud/uppy/node_modules/tus-js-client/lib.esm/upload.js"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global window */\nimport { Base64 } from 'js-base64';\nimport URL from 'url-parse';\nimport DetailedError from './error';\nimport { log } from './logger';\nimport uuid from './uuid';\nvar defaultOptions = {\n  endpoint: null,\n  uploadUrl: null,\n  metadata: {},\n  fingerprint: null,\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  _onUploadUrlAvailable: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  onBeforeRequest: null,\n  onAfterResponse: null,\n  onShouldRetry: null,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false,\n  urlStorage: null,\n  fileReader: null,\n  httpStack: null\n};\n\nvar BaseUpload = /*#__PURE__*/function () {\n  function BaseUpload(file, options) {\n    _classCallCheck(this, BaseUpload);\n\n    // Warn about removed options from previous versions\n    if ('resume' in options) {\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console\n    } // The default options will already be added from the wrapper classes.\n\n\n    this.options = options; // Cast chunkSize to integer\n\n    this.options.chunkSize = +this.options.chunkSize; // The storage module used to store URLs\n\n    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying request object for the current PATCH request\n\n    this._req = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,\n\n    this._urlStorageKey = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Zero indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploadUrls = null;\n  }\n  /**\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\n   * request to the specified upload URL. This is only possible if the server supports the\n   * Termination extension. If the `options.retryDelays` property is set, the method will\n   * also retry if an error ocurrs.\n   *\n   * @param {String} url The upload's URL which will be terminated.\n   * @param {object} options Optional options for influencing HTTP requests.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n\n\n  _createClass(BaseUpload, [{\n    key: \"findPreviousUploads\",\n    value: function findPreviousUploads() {\n      var _this = this;\n\n      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {\n        return _this._urlStorage.findUploadsByFingerprint(fingerprint);\n      });\n    }\n  }, {\n    key: \"resumeFromPreviousUpload\",\n    value: function resumeFromPreviousUpload(previousUpload) {\n      this.url = previousUpload.uploadUrl || null;\n      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;\n      this._urlStorageKey = previousUpload.urlStorageKey;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error('tus: no file or stream to upload provided'));\n\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));\n\n        return;\n      }\n\n      var retryDelays = this.options.retryDelays;\n\n      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\n        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));\n\n        return;\n      }\n\n      if (this.options.parallelUploads > 1) {\n        // Test which options are incompatible with parallel uploads.\n        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {\n          if (_this2.options[optionName]) {\n            _this2._emitError(new Error(\"tus: cannot use the \".concat(optionName, \" option when parallelUploads is enabled\")));\n          }\n        });\n      }\n\n      this.options.fingerprint(file, this.options).then(function (fingerprint) {\n        if (fingerprint == null) {\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');\n        } else {\n          log(\"Calculated fingerprint: \".concat(fingerprint));\n        }\n\n        _this2._fingerprint = fingerprint;\n\n        if (_this2._source) {\n          return _this2._source;\n        }\n\n        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);\n      }).then(function (source) {\n        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from\n        // an upload which used multiple requests, we start a parallel upload.\n\n        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {\n          _this2._startParallelUpload();\n        } else {\n          _this2._startSingleUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this2._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a parallelized upload, where one file is split into\n     * multiple request which are run in parallel.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startParallelUpload\",\n    value: function _startParallelUpload() {\n      var _this3 = this;\n\n      var totalSize = this._size = this._source.size;\n      var totalProgress = 0;\n      this._parallelUploads = [];\n      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate\n      // requests. Here we generate the start and end position for the slices.\n\n      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs\n\n      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective\n      // upload is completed.\n\n      var uploads = parts.map(function (part, index) {\n        var lastPartProgress = 0;\n        return _this3._source.slice(part.start, part.end).then(function (_ref) {\n          var value = _ref.value;\n          return new Promise(function (resolve, reject) {\n            // Merge with the user supplied options but overwrite some values.\n            var options = _objectSpread(_objectSpread({}, _this3.options), {}, {\n              // If available, the partial upload should be resumed from a previous URL.\n              uploadUrl: part.uploadUrl || null,\n              // We take manually care of resuming for partial uploads, so they should\n              // not be stored in the URL storage.\n              storeFingerprintForResuming: false,\n              removeFingerprintOnSuccess: false,\n              // Reset the parallelUploads option to not cause recursion.\n              parallelUploads: 1,\n              metadata: {},\n              // Add the header to indicate the this is a partial upload.\n              headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {\n                'Upload-Concat': 'partial'\n              }),\n              // Reject or resolve the promise if the upload errors or completes.\n              onSuccess: resolve,\n              onError: reject,\n              // Based in the progress for this partial upload, calculate the progress\n              // for the entire final upload.\n              onProgress: function onProgress(newPartProgress) {\n                totalProgress = totalProgress - lastPartProgress + newPartProgress;\n                lastPartProgress = newPartProgress;\n\n                _this3._emitProgress(totalProgress, totalSize);\n              },\n              // Wait until every partial upload has an upload URL, so we can add\n              // them to the URL storage.\n              _onUploadUrlAvailable: function _onUploadUrlAvailable() {\n                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL\n\n                if (_this3._parallelUploadUrls.filter(function (u) {\n                  return !!u;\n                }).length === parts.length) {\n                  _this3._saveUploadInUrlStorage();\n                }\n              }\n            });\n\n            var upload = new BaseUpload(value, options);\n            upload.start(); // Store the upload in an array, so we can later abort them if necessary.\n\n            _this3._parallelUploads.push(upload);\n          });\n        });\n      });\n      var req; // Wait until all partial uploads are finished and we can send the POST request for\n      // creating the final upload.\n\n      Promise.all(uploads).then(function () {\n        req = _this3._openRequest('POST', _this3.options.endpoint);\n        req.setHeader('Upload-Concat', \"final;\".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added\n\n        var metadata = encodeMetadata(_this3.options.metadata);\n\n        if (metadata !== '') {\n          req.setHeader('Upload-Metadata', metadata);\n        }\n\n        return _this3._sendRequest(req, null);\n      }).then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this3.url = resolveUrl(_this3.options.endpoint, location);\n        log(\"Created upload at \".concat(_this3.url));\n\n        _this3._emitSuccess();\n      })[\"catch\"](function (err) {\n        _this3._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\n     * uploaded in a sequential matter.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startSingleUpload\",\n    value: function _startSingleUpload() {\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n\n        if (isNaN(this._size)) {\n          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));\n\n          return;\n        }\n      } else {\n        this._size = this._source.size;\n\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option\"));\n\n          return;\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _performUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        log(\"Resuming upload from previous URL: \".concat(this.url));\n\n        this._resumeUpload();\n\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n\n      if (this.options.uploadUrl != null) {\n        log(\"Resuming upload from provided URL: \".concat(this.options.uploadUrl));\n        this.url = this.options.uploadUrl;\n\n        this._resumeUpload();\n\n        return;\n      } // An upload has not started for the file yet, so we start a new one\n\n\n      log('Creating a new upload');\n\n      this._createUpload();\n    }\n    /**\n     * Abort any running request and stop the current upload. After abort is called, no event\n     * handler will be invoked anymore. You can use the `start` method to resume the upload\n     * again.\n     * If `shouldTerminate` is true, the `terminate` function will be called to remove the\n     * current upload from the server.\n     *\n     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\n     * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate) {\n      var _this4 = this;\n\n      // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.\n\n\n      if (this._parallelUploads != null) {\n        this._parallelUploads.forEach(function (upload) {\n          upload.abort(shouldTerminate);\n        });\n      } // Stop any current running request.\n\n\n      if (this._req !== null) {\n        this._req.abort();\n\n        this._source.close();\n      }\n\n      this._aborted = true; // Stop any timeout used for initiating a retry.\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      if (!shouldTerminate || this.url == null) {\n        return Promise.resolve();\n      }\n\n      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.\n      .then(function () {\n        return _this4._removeFromUrlStorage();\n      });\n    }\n  }, {\n    key: \"_emitHttpError\",\n    value: function _emitHttpError(req, res, message, causingErr) {\n      this._emitError(new DetailedError(message, causingErr, req, res));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      var _this5 = this;\n\n      // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\n      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.\n\n      if (this.options.retryDelays != null) {\n        // We will reset the attempt counter if\n        // - we were already able to connect to the server (offset != null) and\n        // - we were able to upload a small chunk of data to the server\n        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;\n\n        if (shouldResetDelays) {\n          this._retryAttempt = 0;\n        }\n\n        if (shouldRetry(err, this._retryAttempt, this.options)) {\n          var delay = this.options.retryDelays[this._retryAttempt++];\n          this._offsetBeforeRetry = this._offset;\n          this._retryTimeout = setTimeout(function () {\n            _this5.start();\n          }, delay);\n          return;\n        }\n      }\n\n      if (typeof this.options.onError === 'function') {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n    /**\n     * Publishes notification if the upload has been successfully completed.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (this.options.removeFingerprintOnSuccess) {\n        // Remove stored fingerprint and corresponding endpoint. This causes\n        // new uploads of the same file to be treated as a different file.\n        this._removeFromUrlStorage();\n      }\n\n      if (typeof this.options.onSuccess === 'function') {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     *\n     * @param {number} bytesSent  Number of bytes sent to the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === 'function') {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param {number} chunkSize  Size of the chunk that was accepted by the server.\n     * @param {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === 'function') {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this6 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));\n\n        return;\n      }\n\n      var req = this._openRequest('POST', this.options.endpoint);\n\n      if (this.options.uploadLengthDeferred) {\n        req.setHeader('Upload-Defer-Length', 1);\n      } else {\n        req.setHeader('Upload-Length', this._size);\n      } // Add metadata if values have been added\n\n\n      var metadata = encodeMetadata(this.options.metadata);\n\n      if (metadata !== '') {\n        req.setHeader('Upload-Metadata', metadata);\n      }\n\n      var promise;\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        promise = this._addChunkToRequest(req);\n      } else {\n        promise = this._sendRequest(req, null);\n      }\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this6.url = resolveUrl(_this6.options.endpoint, location);\n        log(\"Created upload at \".concat(_this6.url));\n\n        if (typeof _this6.options._onUploadUrlAvailable === 'function') {\n          _this6.options._onUploadUrlAvailable();\n        }\n\n        if (_this6._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this6._emitSuccess();\n\n          _this6._source.close();\n\n          return;\n        }\n\n        _this6._saveUploadInUrlStorage();\n\n        if (_this6.options.uploadDataDuringCreation) {\n          _this6._handleUploadResponse(req, res);\n        } else {\n          _this6._offset = 0;\n\n          _this6._performUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);\n      });\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this7 = this;\n\n      var req = this._openRequest('HEAD', this.url);\n\n      var promise = this._sendRequest(req, null);\n\n      promise.then(function (res) {\n        var status = res.getStatus();\n\n        if (!inStatusCategory(status, 200)) {\n          if (inStatusCategory(status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this7._removeFromUrlStorage();\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n\n          if (status === 423) {\n            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');\n\n            return;\n          }\n\n          if (!_this7.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');\n\n            return;\n          } // Try to create a new upload\n\n\n          _this7.url = null;\n\n          _this7._createUpload();\n\n          return;\n        }\n\n        var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n        if (isNaN(offset)) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n          return;\n        }\n\n        var length = parseInt(res.getHeader('Upload-Length'), 10);\n\n        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');\n\n          return;\n        }\n\n        if (typeof _this7.options._onUploadUrlAvailable === 'function') {\n          _this7.options._onUploadUrlAvailable();\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n\n        if (offset === length) {\n          _this7._emitProgress(length, length);\n\n          _this7._emitSuccess();\n\n          return;\n        }\n\n        _this7._offset = offset;\n\n        _this7._performUpload();\n      })[\"catch\"](function (err) {\n        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);\n      });\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_performUpload\",\n    value: function _performUpload() {\n      var _this8 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n\n      var req; // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        req = this._openRequest('POST', this.url);\n        req.setHeader('X-HTTP-Method-Override', 'PATCH');\n      } else {\n        req = this._openRequest('PATCH', this.url);\n      }\n\n      req.setHeader('Upload-Offset', this._offset);\n\n      var promise = this._addChunkToRequest(req);\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');\n\n          return;\n        }\n\n        _this8._handleUploadResponse(req, res);\n      })[\"catch\"](function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this8._aborted) {\n          return;\n        }\n\n        _this8._emitHttpError(req, null, \"tus: failed to upload chunk at offset \".concat(_this8._offset), err);\n      });\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied request object. It will not handle the response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(req) {\n      var _this9 = this;\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n      req.setProgressHandler(function (bytesSent) {\n        _this9._emitProgress(start + bytesSent, _this9._size);\n      });\n      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      return this._source.slice(start, end).then(function (_ref2) {\n        var value = _ref2.value,\n            done = _ref2.done;\n\n        // If the upload length is deferred, the upload size was not specified during\n        // upload creation. So, if the file reader is done reading, we know the total\n        // upload size and can tell the tus server.\n        if (_this9.options.uploadLengthDeferred && done) {\n          _this9._size = _this9._offset + (value && value.size ? value.size : 0);\n          req.setHeader('Upload-Length', _this9._size);\n        }\n\n        if (value === null) {\n          return _this9._sendRequest(req);\n        }\n\n        _this9._emitProgress(_this9._offset, _this9._size);\n\n        return _this9._sendRequest(req, value);\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(req, res) {\n      var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n      if (isNaN(offset)) {\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n\n        this._source.close();\n\n        return;\n      }\n\n      this._performUpload();\n    }\n    /**\n     * Create a new HTTP request object with the given method and URL.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_openRequest\",\n    value: function _openRequest(method, url) {\n      var req = openRequest(method, url, this.options);\n      this._req = req;\n      return req;\n    }\n    /**\n     * Remove the entry in the URL storage, if it has been saved before.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_removeFromUrlStorage\",\n    value: function _removeFromUrlStorage() {\n      var _this10 = this;\n\n      if (!this._urlStorageKey) return;\n\n      this._urlStorage.removeUpload(this._urlStorageKey)[\"catch\"](function (err) {\n        _this10._emitError(err);\n      });\n\n      this._urlStorageKey = null;\n    }\n    /**\n     * Add the upload URL to the URL storage, if possible.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_saveUploadInUrlStorage\",\n    value: function _saveUploadInUrlStorage() {\n      var _this11 = this;\n\n      // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.\n      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {\n        return;\n      }\n\n      var storedUpload = {\n        size: this._size,\n        metadata: this.options.metadata,\n        creationTime: new Date().toString()\n      };\n\n      if (this._parallelUploads) {\n        // Save multiple URLs if the parallelUploads option is used ...\n        storedUpload.parallelUploadUrls = this._parallelUploadUrls;\n      } else {\n        // ... otherwise we just save the one available URL.\n        storedUpload.uploadUrl = this.url;\n      }\n\n      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {\n        return _this11._urlStorageKey = urlStorageKey;\n      })[\"catch\"](function (err) {\n        _this11._emitError(err);\n      });\n    }\n    /**\n     * Send a request with the provided body.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_sendRequest\",\n    value: function _sendRequest(req) {\n      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return sendRequest(req, body, this.options);\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options) {\n      // Count the number of arguments to see if a callback is being provided as the last\n      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {\n        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Note that in order for the trick above to work, a default value cannot be set for `options`,\n      // so the check below replaces the old default `{}`.\n\n\n      if (options === undefined) {\n        options = {};\n      }\n\n      var req = openRequest('DELETE', url, options);\n      return sendRequest(req, null, options).then(function (res) {\n        // A 204 response indicates a successfull request\n        if (res.getStatus() === 204) {\n          return;\n        }\n\n        throw new DetailedError('tus: unexpected response while terminating upload', null, req, res);\n      })[\"catch\"](function (err) {\n        if (!(err instanceof DetailedError)) {\n          err = new DetailedError('tus: failed to terminate upload', err, req, null);\n        }\n\n        if (!shouldRetry(err, 0, options)) {\n          throw err;\n        } // Instead of keeping track of the retry attempts, we remove the first element from the delays\n        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\n        // We recursively call the terminate function will removing elements from the retryDelays array.\n\n\n        var delay = options.retryDelays[0];\n        var remainingDelays = options.retryDelays.slice(1);\n\n        var newOptions = _objectSpread(_objectSpread({}, options), {}, {\n          retryDelays: remainingDelays\n        });\n\n        return new Promise(function (resolve) {\n          return setTimeout(resolve, delay);\n        }).then(function () {\n          return BaseUpload.terminate(url, newOptions);\n        });\n      });\n    }\n  }]);\n\n  return BaseUpload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(\"\".concat(key, \" \").concat(Base64.encode(metadata[key])));\n  }\n\n  return encoded.join(',');\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n/**\n * Create a new HTTP request with the specified method and URL.\n * The necessary headers that are included in every request\n * will be added, including the request ID.\n *\n * @api private\n */\n\n\nfunction openRequest(method, url, options) {\n  var req = options.httpStack.createRequest(method, url);\n  req.setHeader('Tus-Resumable', '1.0.0');\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    req.setHeader(name, headers[name]);\n  }\n\n  if (options.addRequestId) {\n    var requestId = uuid();\n    req.setHeader('X-Request-ID', requestId);\n  }\n\n  return req;\n}\n/**\n * Send a request with the provided body while invoking the onBeforeRequest\n * and onAfterResponse callbacks.\n *\n * @api private\n */\n\n\nfunction sendRequest(req, body, options) {\n  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();\n  return onBeforeRequestPromise.then(function () {\n    return req.send(body).then(function (res) {\n      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();\n      return onAfterResponsePromise.then(function () {\n        return res;\n      });\n    });\n  });\n}\n/**\n * Checks whether the browser running this code has internet access.\n * This function will always return true in the node.js environment\n *\n * @api private\n */\n\n\nfunction isOnline() {\n  var online = true;\n\n  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {\n    online = false;\n  }\n\n  return online;\n}\n/**\n * Checks whether or not it is ok to retry a request.\n * @param {Error} err the error returned from the last request\n * @param {number} retryAttempt the number of times the request has already been retried\n * @param {object} options tus Upload options\n *\n * @api private\n */\n\n\nfunction shouldRetry(err, retryAttempt, options) {\n  // We only attempt a retry if\n  // - retryDelays option is set\n  // - we didn't exceed the maxium number of retries, yet, and\n  // - this error was caused by a request or it's response and\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\n  // a onShouldRetry is specified and returns true\n  // - the browser does not indicate that we are offline\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\n    return false;\n  }\n\n  if (options && typeof options.onShouldRetry === 'function') {\n    return options.onShouldRetry(err, retryAttempt, options);\n  }\n\n  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();\n}\n/**\n * Resolve a relative link given the origin as source. For example,\n * if a HTTP request to http://example.com/files/ returns a Location\n * header with the value /upload/abc, the resolved URL will be:\n * http://example.com/upload/abc\n */\n\n\nfunction resolveUrl(origin, link) {\n  return new URL(link, origin).toString();\n}\n/**\n * Calculate the start and end positions for the parts if an upload\n * is split into multiple parallel requests.\n *\n * @param {number} totalSize The byte size of the upload, which will be split.\n * @param {number} partCount The number in how many parts the upload will be split.\n * @param {string[]} previousUrls The upload URLs for previous parts.\n * @return {object[]}\n * @api private\n */\n\n\nfunction splitSizeIntoParts(totalSize, partCount, previousUrls) {\n  var partSize = Math.floor(totalSize / partCount);\n  var parts = [];\n\n  for (var i = 0; i < partCount; i++) {\n    parts.push({\n      start: partSize * i,\n      end: partSize * (i + 1)\n    });\n  }\n\n  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.\n\n  if (previousUrls) {\n    parts.forEach(function (part, index) {\n      part.uploadUrl = previousUrls[index] || null;\n    });\n  }\n\n  return parts;\n}\n\nBaseUpload.defaultOptions = defaultOptions;\nexport default BaseUpload;"],"mappings":"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"},"metadata":{},"sourceType":"module"}