{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nvar io = requireSocketIo;\nvar Emitter = require('component-emitter');\nvar has = require('@uppy/utils/lib/hasProperty');\nvar parseUrl = require('./parseUrl');\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\nvar fetchWithNetworkError = require('@uppy/utils/lib/fetchWithNetworkError'); // Lazy load socket.io to avoid a console error\n// in IE 10 when the Transloadit plugin is not used.\n// (The console.error call comes from `buffer`. I\n// think we actually don't use that part of socket.io\n// at all…)\n\nvar socketIo;\nfunction requireSocketIo() {\n  if (!socketIo) {\n    socketIo = require('socket.io-client');\n  }\n  return socketIo;\n}\nvar ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';\nvar ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';\nvar ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';\nvar statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];\n/**\n * Check that an assembly status is equal to or larger than some desired status.\n * It checks for things that are larger so that a comparison like this works,\n * when the old assembly status is UPLOADING but the new is FINISHED:\n *\n * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)\n *\n * …so that we can emit the 'executing' event even if the execution step was so\n * fast that we missed it.\n */\n\nfunction isStatus(status, test) {\n  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);\n}\nvar TransloaditAssembly = /*#__PURE__*/function (_Emitter) {\n  _inheritsLoose(TransloaditAssembly, _Emitter);\n  function TransloaditAssembly(assembly) {\n    var _this;\n    _this = _Emitter.call(this) || this; // The current assembly status.\n\n    _this.status = assembly; // The socket.io connection.\n\n    _this.socket = null; // The interval timer for full status updates.\n\n    _this.pollInterval = null; // Whether this assembly has been closed (finished or errored)\n\n    _this.closed = false;\n    return _this;\n  }\n  var _proto = TransloaditAssembly.prototype;\n  _proto.connect = function connect() {\n    this._connectSocket();\n    this._beginPolling();\n  };\n  _proto._onFinished = function _onFinished() {\n    this.emit('finished');\n    this.close();\n  };\n  _proto._connectSocket = function _connectSocket() {\n    var _this2 = this;\n    var parsed = parseUrl(this.status.websocket_url);\n    var socket = io().connect(parsed.origin, {\n      transports: ['websocket'],\n      path: parsed.pathname\n    });\n    socket.on('connect', function () {\n      socket.emit('assembly_connect', {\n        id: _this2.status.assembly_id\n      });\n      _this2.emit('connect');\n    });\n    socket.on('connect_failed', function () {\n      _this2._onError(new NetworkError('Transloadit Socket.io connection error'));\n      _this2.socket = null;\n    });\n    socket.on('error', function () {\n      socket.disconnect();\n      _this2.socket = null;\n    });\n    socket.on('assembly_finished', function () {\n      _this2._onFinished();\n    });\n    socket.on('assembly_upload_finished', function (file) {\n      _this2.emit('upload', file);\n      _this2.status.uploads.push(file);\n    });\n    socket.on('assembly_uploading_finished', function () {\n      _this2.emit('executing');\n    });\n    socket.on('assembly_upload_meta_data_extracted', function () {\n      _this2.emit('metadata');\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    socket.on('assembly_result_finished', function (stepName, result) {\n      _this2.emit('result', stepName, result);\n      if (!_this2.status.results[stepName]) {\n        _this2.status.results[stepName] = [];\n      }\n      _this2.status.results[stepName].push(result);\n    });\n    socket.on('assembly_error', function (err) {\n      _this2._onError(err); // Refetch for updated status code\n\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    this.socket = socket;\n  };\n  _proto._onError = function _onError(err) {\n    this.emit('error', _extends(new Error(err.message), err));\n  }\n  /**\n   * Begin polling for assembly status changes. This sends a request to the\n   * assembly status endpoint every so often, if the socket is not connected.\n   * If the socket connection fails or takes a long time, we won't miss any\n   * events.\n   */;\n\n  _proto._beginPolling = function _beginPolling() {\n    var _this3 = this;\n    this.pollInterval = setInterval(function () {\n      if (!_this3.socket || !_this3.socket.connected) {\n        _this3._fetchStatus();\n      }\n    }, 2000);\n  }\n  /**\n   * Reload assembly status. Useful if the socket doesn't work.\n   *\n   * Pass `diff: false` to avoid emitting diff events, instead only emitting\n   * 'status'.\n   */;\n\n  _proto._fetchStatus = function _fetchStatus(_temp) {\n    var _this4 = this;\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$diff = _ref.diff,\n      diff = _ref$diff === void 0 ? true : _ref$diff;\n    return fetchWithNetworkError(this.status.assembly_ssl_url).then(function (response) {\n      return response.json();\n    }).then(function (status) {\n      // Avoid updating if we closed during this request's lifetime.\n      if (_this4.closed) return;\n      _this4.emit('status', status);\n      if (diff) {\n        _this4.updateStatus(status);\n      } else {\n        _this4.status = status;\n      }\n    }).catch(function (err) {\n      return _this4._onError(err);\n    });\n  };\n  _proto.update = function update() {\n    return this._fetchStatus({\n      diff: true\n    });\n  }\n  /**\n   * Update this assembly's status with a full new object. Events will be\n   * emitted for status changes, new files, and new results.\n   *\n   * @param {object} next The new assembly status object.\n   */;\n\n  _proto.updateStatus = function updateStatus(next) {\n    this._diffStatus(this.status, next);\n    this.status = next;\n  }\n  /**\n   * Diff two assembly statuses, and emit the events necessary to go from `prev`\n   * to `next`.\n   *\n   * @param {object} prev The previous assembly status.\n   * @param {object} next The new assembly status.\n   */;\n\n  _proto._diffStatus = function _diffStatus(prev, next) {\n    var _this5 = this;\n    var prevStatus = prev.ok;\n    var nextStatus = next.ok;\n    if (next.error && !prev.error) {\n      return this._onError(next);\n    } // Desired emit order:\n    //  - executing\n    //  - (n × upload)\n    //  - metadata\n    //  - (m × result)\n    //  - finished\n    // The below checks run in this order, that way even if we jump from\n    // UPLOADING straight to FINISHED all the events are emitted as expected.\n\n    var nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);\n    if (nowExecuting) {\n      // Without WebSockets, this is our only way to tell if uploading finished.\n      // Hence, we emit this just before the 'upload's and before the 'metadata'\n      // event for the most intuitive ordering, corresponding to the _usual_\n      // ordering (if not guaranteed) that you'd get on the WebSocket.\n      this.emit('executing');\n    } // Find new uploaded files.\n\n    Object.keys(next.uploads).filter(function (upload) {\n      return !has(prev.uploads, upload);\n    }).map(function (upload) {\n      return next.uploads[upload];\n    }).forEach(function (upload) {\n      _this5.emit('upload', upload);\n    });\n    if (nowExecuting) {\n      this.emit('metadata');\n    } // Find new results.\n\n    Object.keys(next.results).forEach(function (stepName) {\n      var nextResults = next.results[stepName];\n      var prevResults = prev.results[stepName];\n      nextResults.filter(function (n) {\n        return !prevResults || !prevResults.some(function (p) {\n          return p.id === n.id;\n        });\n      }).forEach(function (result) {\n        _this5.emit('result', stepName, result);\n      });\n    });\n    if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {\n      this.emit('finished');\n    }\n  }\n  /**\n   * Stop updating this assembly.\n   */;\n\n  _proto.close = function close() {\n    this.closed = true;\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    clearInterval(this.pollInterval);\n  };\n  return TransloaditAssembly;\n}(Emitter);\nmodule.exports = TransloaditAssembly;","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","io","requireSocketIo","Emitter","require","has","parseUrl","NetworkError","fetchWithNetworkError","socketIo","ASSEMBLY_UPLOADING","ASSEMBLY_EXECUTING","ASSEMBLY_COMPLETED","statusOrder","isStatus","status","test","indexOf","TransloaditAssembly","_Emitter","assembly","_this","socket","pollInterval","closed","_proto","connect","_connectSocket","_beginPolling","_onFinished","emit","close","_this2","parsed","websocket_url","origin","transports","path","pathname","on","id","assembly_id","_onError","disconnect","file","uploads","push","_fetchStatus","diff","stepName","result","results","err","Error","message","_this3","setInterval","connected","_temp","_this4","_ref","_ref$diff","assembly_ssl_url","then","response","json","updateStatus","catch","update","next","_diffStatus","prev","_this5","prevStatus","ok","nextStatus","error","nowExecuting","keys","filter","upload","map","forEach","nextResults","prevResults","n","some","clearInterval","module","exports"],"sources":["E:/integrate cloud/uppy/node_modules/@uppy/transloadit/lib/Assembly.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar io = requireSocketIo;\n\nvar Emitter = require('component-emitter');\n\nvar has = require('@uppy/utils/lib/hasProperty');\n\nvar parseUrl = require('./parseUrl');\n\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\n\nvar fetchWithNetworkError = require('@uppy/utils/lib/fetchWithNetworkError'); // Lazy load socket.io to avoid a console error\n// in IE 10 when the Transloadit plugin is not used.\n// (The console.error call comes from `buffer`. I\n// think we actually don't use that part of socket.io\n// at all…)\n\n\nvar socketIo;\n\nfunction requireSocketIo() {\n  if (!socketIo) {\n    socketIo = require('socket.io-client');\n  }\n\n  return socketIo;\n}\n\nvar ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';\nvar ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';\nvar ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';\nvar statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];\n/**\n * Check that an assembly status is equal to or larger than some desired status.\n * It checks for things that are larger so that a comparison like this works,\n * when the old assembly status is UPLOADING but the new is FINISHED:\n *\n * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)\n *\n * …so that we can emit the 'executing' event even if the execution step was so\n * fast that we missed it.\n */\n\nfunction isStatus(status, test) {\n  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);\n}\n\nvar TransloaditAssembly = /*#__PURE__*/function (_Emitter) {\n  _inheritsLoose(TransloaditAssembly, _Emitter);\n\n  function TransloaditAssembly(assembly) {\n    var _this;\n\n    _this = _Emitter.call(this) || this; // The current assembly status.\n\n    _this.status = assembly; // The socket.io connection.\n\n    _this.socket = null; // The interval timer for full status updates.\n\n    _this.pollInterval = null; // Whether this assembly has been closed (finished or errored)\n\n    _this.closed = false;\n    return _this;\n  }\n\n  var _proto = TransloaditAssembly.prototype;\n\n  _proto.connect = function connect() {\n    this._connectSocket();\n\n    this._beginPolling();\n  };\n\n  _proto._onFinished = function _onFinished() {\n    this.emit('finished');\n    this.close();\n  };\n\n  _proto._connectSocket = function _connectSocket() {\n    var _this2 = this;\n\n    var parsed = parseUrl(this.status.websocket_url);\n    var socket = io().connect(parsed.origin, {\n      transports: ['websocket'],\n      path: parsed.pathname\n    });\n    socket.on('connect', function () {\n      socket.emit('assembly_connect', {\n        id: _this2.status.assembly_id\n      });\n\n      _this2.emit('connect');\n    });\n    socket.on('connect_failed', function () {\n      _this2._onError(new NetworkError('Transloadit Socket.io connection error'));\n\n      _this2.socket = null;\n    });\n    socket.on('error', function () {\n      socket.disconnect();\n      _this2.socket = null;\n    });\n    socket.on('assembly_finished', function () {\n      _this2._onFinished();\n    });\n    socket.on('assembly_upload_finished', function (file) {\n      _this2.emit('upload', file);\n\n      _this2.status.uploads.push(file);\n    });\n    socket.on('assembly_uploading_finished', function () {\n      _this2.emit('executing');\n    });\n    socket.on('assembly_upload_meta_data_extracted', function () {\n      _this2.emit('metadata');\n\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    socket.on('assembly_result_finished', function (stepName, result) {\n      _this2.emit('result', stepName, result);\n\n      if (!_this2.status.results[stepName]) {\n        _this2.status.results[stepName] = [];\n      }\n\n      _this2.status.results[stepName].push(result);\n    });\n    socket.on('assembly_error', function (err) {\n      _this2._onError(err); // Refetch for updated status code\n\n\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    this.socket = socket;\n  };\n\n  _proto._onError = function _onError(err) {\n    this.emit('error', _extends(new Error(err.message), err));\n  }\n  /**\n   * Begin polling for assembly status changes. This sends a request to the\n   * assembly status endpoint every so often, if the socket is not connected.\n   * If the socket connection fails or takes a long time, we won't miss any\n   * events.\n   */\n  ;\n\n  _proto._beginPolling = function _beginPolling() {\n    var _this3 = this;\n\n    this.pollInterval = setInterval(function () {\n      if (!_this3.socket || !_this3.socket.connected) {\n        _this3._fetchStatus();\n      }\n    }, 2000);\n  }\n  /**\n   * Reload assembly status. Useful if the socket doesn't work.\n   *\n   * Pass `diff: false` to avoid emitting diff events, instead only emitting\n   * 'status'.\n   */\n  ;\n\n  _proto._fetchStatus = function _fetchStatus(_temp) {\n    var _this4 = this;\n\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$diff = _ref.diff,\n        diff = _ref$diff === void 0 ? true : _ref$diff;\n\n    return fetchWithNetworkError(this.status.assembly_ssl_url).then(function (response) {\n      return response.json();\n    }).then(function (status) {\n      // Avoid updating if we closed during this request's lifetime.\n      if (_this4.closed) return;\n\n      _this4.emit('status', status);\n\n      if (diff) {\n        _this4.updateStatus(status);\n      } else {\n        _this4.status = status;\n      }\n    }).catch(function (err) {\n      return _this4._onError(err);\n    });\n  };\n\n  _proto.update = function update() {\n    return this._fetchStatus({\n      diff: true\n    });\n  }\n  /**\n   * Update this assembly's status with a full new object. Events will be\n   * emitted for status changes, new files, and new results.\n   *\n   * @param {object} next The new assembly status object.\n   */\n  ;\n\n  _proto.updateStatus = function updateStatus(next) {\n    this._diffStatus(this.status, next);\n\n    this.status = next;\n  }\n  /**\n   * Diff two assembly statuses, and emit the events necessary to go from `prev`\n   * to `next`.\n   *\n   * @param {object} prev The previous assembly status.\n   * @param {object} next The new assembly status.\n   */\n  ;\n\n  _proto._diffStatus = function _diffStatus(prev, next) {\n    var _this5 = this;\n\n    var prevStatus = prev.ok;\n    var nextStatus = next.ok;\n\n    if (next.error && !prev.error) {\n      return this._onError(next);\n    } // Desired emit order:\n    //  - executing\n    //  - (n × upload)\n    //  - metadata\n    //  - (m × result)\n    //  - finished\n    // The below checks run in this order, that way even if we jump from\n    // UPLOADING straight to FINISHED all the events are emitted as expected.\n\n\n    var nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);\n\n    if (nowExecuting) {\n      // Without WebSockets, this is our only way to tell if uploading finished.\n      // Hence, we emit this just before the 'upload's and before the 'metadata'\n      // event for the most intuitive ordering, corresponding to the _usual_\n      // ordering (if not guaranteed) that you'd get on the WebSocket.\n      this.emit('executing');\n    } // Find new uploaded files.\n\n\n    Object.keys(next.uploads).filter(function (upload) {\n      return !has(prev.uploads, upload);\n    }).map(function (upload) {\n      return next.uploads[upload];\n    }).forEach(function (upload) {\n      _this5.emit('upload', upload);\n    });\n\n    if (nowExecuting) {\n      this.emit('metadata');\n    } // Find new results.\n\n\n    Object.keys(next.results).forEach(function (stepName) {\n      var nextResults = next.results[stepName];\n      var prevResults = prev.results[stepName];\n      nextResults.filter(function (n) {\n        return !prevResults || !prevResults.some(function (p) {\n          return p.id === n.id;\n        });\n      }).forEach(function (result) {\n        _this5.emit('result', stepName, result);\n      });\n    });\n\n    if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {\n      this.emit('finished');\n    }\n  }\n  /**\n   * Stop updating this assembly.\n   */\n  ;\n\n  _proto.close = function close() {\n    this.closed = true;\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    clearInterval(this.pollInterval);\n  };\n\n  return TransloaditAssembly;\n}(Emitter);\n\nmodule.exports = TransloaditAssembly;"],"mappings":"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"},"metadata":{},"sourceType":"script"}