{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\n\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n  if (a instanceof Blob) {\n    return new Blob([a, b], {\n      type: a.type\n    });\n  }\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n  throw new Error('Unknown data type');\n}\nvar StreamSource = /*#__PURE__*/function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (start < this._bufferOffset) {\n        return Promise.reject(new Error(\"Requested data is before the reader's current offset\"));\n      }\n      return this._readUntilEnoughDataOrDone(start, end);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end) {\n      var _this = this;\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n        var done = value == null ? this._done : false;\n        return Promise.resolve({\n          value: value,\n          done: done\n        });\n      }\n      return this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n          done = _ref.done;\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n        return _this._readUntilEnoughDataOrDone(start, end);\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      } // If the buffer is empty after removing old data, all data has been read.\n\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      } // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n  return StreamSource;\n}();\nexport { StreamSource as default };","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","len","blobOrArray","undefined","size","concat","a","b","Blob","type","set","c","constructor","Error","StreamSource","reader","chunkSize","_chunkSize","_buffer","_bufferOffset","_reader","_done","value","slice","start","end","Promise","reject","_readUntilEnoughDataOrDone","_this","hasEnoughData","_getDataFromBuffer","done","resolve","read","then","_ref","hasAllDataBeenRead","close","cancel","default"],"sources":["E:/integrate cloud/uppy/node_modules/tus-js-client/lib.esm/browser/sources/StreamSource.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\n\n\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n\n  if (a instanceof Blob) {\n    return new Blob([a, b], {\n      type: a.type\n    });\n  }\n\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n\n  throw new Error('Unknown data type');\n}\n\nvar StreamSource = /*#__PURE__*/function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (start < this._bufferOffset) {\n        return Promise.reject(new Error(\"Requested data is before the reader's current offset\"));\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end) {\n      var _this = this;\n\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n\n        var done = value == null ? this._done : false;\n        return Promise.resolve({\n          value: value,\n          done: done\n        });\n      }\n\n      return this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n\n        return _this._readUntilEnoughDataOrDone(start, end);\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      } // If the buffer is empty after removing old data, all data has been read.\n\n\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      } // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n\n\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n\n  return StreamSource;\n}();\n\nexport { StreamSource as default };"],"mappings":"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"},"metadata":{},"sourceType":"module"}